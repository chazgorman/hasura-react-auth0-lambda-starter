MAKE_ENV:=development
# ROOT_DIR:=$(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
# DOTENV := .env


# ECR_REPO_URL_BASE := 840787491930.dkr.ecr.us-west-2.amazonaws.com
# ECR_AP_BASE_REPO_NAME := ap_karada_base
# ECR_AP_BASE_REPO_URL := ${ECR_REPO_URL_BASE}/${ECR_AP_BASE_REPO_NAME}

# ECR_REPO_NAME := ap_aws_test
# ECR_REPO_URL := ${ECR_REPO_URL_BASE}/${ECR_REPO_NAME}


.ONESHELL:
SHELL=/bin/bash 
.EXPORT_ALL_VARIABLES:

include .env.${MAKE_ENV}

test_env: 
	echo ${HASURA_GRAPHQL_JWT_KEY_RAW}

install:
	brew install gettext
	brew link --force gettext 

setup_env:
	echo '### DO NOT EDIT THIS FILE DIRECTLY' > .env.${MAKE_ENV} ; \
	cat .env.${MAKE_ENV}.base | envsubst >> .env.${MAKE_ENV} ;
	# cat "<!-- DO NOT EDIT THIS FILE!!!  -->" | envsubst > "../frontend-ios/env.plist"; \
	# cat "../frontend-ios/env.tpl.plist" | envsubst >> "../frontend-ios/env.plist"; \

ngrok: 
	export NGROK=.ngrok-generated.yml ;  envsubst < ngrok-base.yml > $${NGROK} ; \
	ngrok start -config $${NGROK} --all 

ngrok_silent:
	export NGROK=.ngrok-generated.yml ;  envsubst < ngrok-base.yml > $${NGROK} ; \
	ngrok start -config $${NGROK} --all > /dev/null 

tf_setup:
	cd ../backend-terraform ; \
	./init-tf-bucket.sh

tf_authzero_init:
	cd ../backend-terraform ; \
	./run-terraform-authzero.sh init

tf_authzero_apply:
	cd ../backend-terraform ; \
	./run-terraform-authzero.sh apply


###### OLD COMMANDS: 


sls_local: 
	cd ../backend-lambdas; \
	node --max-old-space-size=4096 node_modules/serverless/bin/serverless offline --useSeparateProcesses --useChildProcesses start 

gql_gen_all: gql_gen_ios gql_gen_sls
# gql_gen_all: gql_gen_ios gql_gen_sls

# gql_gen_ios: gql_gen_ios_schema

gql_gen_components:
	gql-gen --config gql-codegen.yml

# gql_gen_sls: gql_gen_sls_schema
	# echo "done"

gql_gen_sls: gql_gen_sls_schema
	cd ../backend-lambdas; \
	gql-gen --config gql-codegen.yml \
	cd -;

gql_gen_sls_schema: 
	cd ../backend-lambdas; \
	mkdir -p ./src/__generated__/; \
	gq ${REACT_APP_HASURA_ENDPOINT} -H "X-Hasura-Admin-Secret: ${HASURA_GRAPHQL_ADMIN_SECRET}" --introspect --format json > ./src/__generated__/schema.json;  \
	gq ${LAMBDA_ENDPOINT} --introspect --format json > ./src/__generated__/lambda_schema.json ; \
	cd -


# gql_gen_ios_schema: hasura_metadata_reload
# 	mkdir -p ../${IOS_APP_SRC}/__generated__/ ;\
# 	gq ${REACT_APP_HASURA_ENDPOINT}  -H "X-Hasura-Admin-Secret: ${HASURA_GRAPHQL_ADMIN_SECRET}" --introspect --format json > ../${IOS_APP_SRC}/__generated__/schema.json

hasura_up:
	export HASURA_GRAPHQL_JWT_KEY_RAW=$$(curl -L "http://${REACT_APP_AUTH0_DOMAIN}/pem" );\
	cd ../backend-hasura; \
	docker-compose kill; \
	docker-compose up --build --abort-on-container-exit\

hasura_up_delay:
	for i in `seq 1 300` ; \
	do \
		curl -f -s ${LAMBDA_ENDPOINT} && sleep 5 && make hasura_up && exit 0 ; \
		echo . ;\
		sleep 5 ;\
	done ;\
	echo Failed waiting for sls lambdas && exit 1

hasura_metadata_reload:
	cd ../backend-hasura; \
	echo "MD UPDATE"; \
	hasura metadata reload --skip-update-check --admin-secret ${HASURA_GRAPHQL_ADMIN_SECRET} --endpoint http://localhost:${HASURA_EXPOSED_PORT} 

hasura_migrate_apply:
	cd ../backend-hasura; \
	hasura migrate apply --skip-update-check --admin-secret ${HASURA_GRAPHQL_ADMIN_SECRET} --endpoint http://localhost:${HASURA_EXPOSED_PORT} 

hasura_migrate_apply_production:
	# export $(grep -v '^#' ../sc-common/.env.production | sed -e 's/\\n/__NEWLINE__/g' | sed -e 's/=__NEWLINE__-----END CERTIFICATE-----__NEWLINE__/__END_CERT__/' | sed -e 's/ /__SPACE__/g' | xargs) ; 
	export PROD_HASURA_SECRET=$$(grep HASURA_GRAPHQL_ADMIN_SECRET ../sc-common/.env.production | sed -e 's/.*\=//' ) ;\
	echo "Admin secret: '$${PROD_HASURA_SECRET}' . " ;\
	REMOTE_ENDPOINT=https://hasura.production.$${HASURA_TF_AWS_DOMAIN} ; \
	read -p "Are you sure you want to migrate to $${REMOTE_ENDPOINT} [y/n]? " -n 1 -r; \
	if [[ $$REPLY =~ ^[Yy] ]]; \
	then \
		printf "\nyes going ahead\n"; \
		cd ../backend-hasura; \
		hasura migrate apply --skip-update-check --admin-secret $${PROD_HASURA_SECRET} --endpoint $${REMOTE_ENDPOINT} ;\
	else \
		printf "\n skipping\n"  ;\
	fi

hasura_console_delay: 
	for i in `seq 1 300` ; \
	do \
		curl -f -s http://localhost:${HASURA_EXPOSED_PORT} && make hasura_console && exit 0 ;\
		echo  . ;\
		sleep 5 ;\
	done; \
	echo Failed waiting for rails && exit 1

hasura_console: 
	cd ../backend-hasura; \
	hasura console --admin-secret ${HASURA_GRAPHQL_ADMIN_SECRET} --skip-update-check --no-browser --console-port ${HASURA_CONSOLE_PORT} --endpoint http://localhost:${HASURA_EXPOSED_PORT}

hasura_migrate_squash:
	cd ../backend-hasura && \
	cp -rf migrations/*MANUAL_SQL_MIGRATION* manual-migrations/ && \
	git mv migrations `date +%F`-migrations && \
	mkdir -p migrations && \
	hasura migrate create "init" --from-server --skip-update-check --admin-secret ${HASURA_GRAPHQL_ADMIN_SECRET} --endpoint http://localhost:${HASURA_EXPOSED_PORT}  && \
	mv migrations/*_init migrations/0000000000001_init && \
	cp -r manual-migrations/* migrations/ && \
	echo "Remember the CITEXT extension, enum stuff, and cancellation policies"


hasura_migrate_prod:
	echo 'UNIMPLEMENTED'


hack_fix_react_scripts:
	sed -i "" "s/protocol: 'ws',/protocol: window.location.protocol === 'https:' ? 'wss' : 'ws',/g" node_modules/react-dev-utils/webpackHotDevClient.js


copy_envs:
	echo "#### DO NOT EDIT THIS FILE, edit ${DOTENV} ####" > .env ; \
	grep '^REACT_APP' ${DOTENV} >> .env

prep_app: hack_fix_react_scripts copy_envs

# 
# # https://askubuntu.com/questions/682869/how-do-i-install-a-different-python-version-using-apt-get
# # Need to force python 3.5
# ap_docker_base_build: ap_models
# 	echo "--- Building Base Docker Image"
# 	export $$(grep -v '^#' ${DOTENV} | xargs)  && \
# 	cd ../../AlphaPose && \
# 	aws --profile $${AWS_CLI_PROFILE} ecr list-images \
# 		--repository-name ${ECR_AP_BASE_REPO_NAME} --region us-west-2 | \
# 		grep $${AP_BASE_IMAGE_DOCKER_VERSION} || \
# 	docker build -t ${ECR_AP_BASE_REPO_URL}:$${AP_BASE_IMAGE_DOCKER_VERSION}  .
# 
# ap_docker_build: ap_docker_base_build
# 	echo "--- Building Docker Image"
# 	export $$(grep -v '^#' ${DOTENV} | xargs)  && \
# 	cd ../../AlphaPose/karada-additions && \
# 	echo "version = \"$${AP_DOCKER_VERSION}\"" >> version.py && \
# 	aws --profile $${AWS_CLI_PROFILE} ecr list-images \
# 		--repository-name ${ECR_REPO_NAME} --region us-west-2 | \
# 		grep $${AP_DOCKER_VERSION} || \
# 	docker build -t ${ECR_REPO_URL}:$${AP_DOCKER_VERSION}  \
# 		--build-arg BASE_TAG=$${AP_BASE_IMAGE_DOCKER_VERSION}  .
# 
# ap_docker_base_push: ap_docker_base_build
# 	echo "--- Pushing Base Docker Image"
# 	export $$(grep -v '^#' ${DOTENV} | xargs)  && \
# 	cd ../../AlphaPose && \
# 	aws --profile $${AWS_CLI_PROFILE} ecr list-images \
# 		--repository-name ${ECR_AP_BASE_REPO_NAME} --region us-west-2 | \
# 		grep $${AP_BASE_IMAGE_DOCKER_VERSION} || \
# 	($$(aws ecr get-login --no-include-email --region us-west-2 --profile $${AWS_CLI_PROFILE}) && \
# 	docker push ${ECR_AP_BASE_REPO_URL}:$${AP_BASE_IMAGE_DOCKER_VERSION} )
# 
# ap_docker_push: ap_docker_build ap_docker_base_push
# 	echo "--- Pushing Docker Image"
# 	export $$(grep -v '^#' ${DOTENV} | xargs)  && \
# 	cd ../../AlphaPose/karada-additions && \
# 	aws --profile $${AWS_CLI_PROFILE} ecr list-images \
# 		--repository-name ${ECR_REPO_NAME} --region us-west-2 | \
# 		grep $${AP_DOCKER_VERSION} || \
# 	($$(aws ecr get-login --no-include-email --region us-west-2 --profile $${AWS_CLI_PROFILE}) && \
# 	docker push ${ECR_REPO_URL}:$${AP_DOCKER_VERSION} )
# 
# test_ap_docker_image: ap_docker_build
# 	export $$(grep -v '^#' ${DOTENV} | xargs)  && \
# 	docker run \
# 		-e AWS_ACCESS_KEY_ID=$${AWS_ACCESS_KEY_ID} \
# 		-e AWS_SECRET_ACCESS_KEY=$${AWS_SECRET_ACCESS_KEY} \
# 		-e karada_s3_bucket=karada-static-test-files-non-terraform \
# 		-e karada_output_prefix=output/00000000-0000-0000-0000-000000000000 \
# 		-e karada_s3_key=dropbox/00000000-0000-0000-0000-000000000000/test.mp4 \
# 		${ECR_REPO_URL}:$${AP_DOCKER_VERSION} 
# 
# terraform: ap_docker_push
# 	cd backend-terraform && ./deploy.sh
# 	cd backend-terraform && ./run-terraform.sh apply -auto-approve
# 